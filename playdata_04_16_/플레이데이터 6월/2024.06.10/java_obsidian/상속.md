# 상속 
- 상속은 이미 잘 개발된 클래스를 재사용해서 새로운 클래스를 만들기 때문에 중복되는 코드를 줄일수 있음 
![[Pasted image 20240603001544.png]]
- field1와 method1(), field2와 method2()를 가지는 클래스를 모두 처음부터 만드는 것보다 클래스를 상속하고 추가적으로 field2와 method2()를 작성하는 것이 효율적임 
- 상속을 이용하면 부모 클래스의 수정으로 모든 자식 클래스들도 수정되는 효과를 가져오기 때문에 유지 보수 시간을 최소화할 수 있음 
## 클래스 상속 
- 프로그램의 세계에서는 자식이 부모를 선택할 수 있음 
- 자식 클래스를 선언할 때 어떤 부모 클래스를 상속받을 것인지 결정하고, 선택된 부모 클래스는 다음과 같이 extends 뒤에 기술 

```java
class 자식클래스 extends 부모클래스{

}
```
- 작성 방법 
	1. 여러 개의 부모 클래스를 상속할 수 없음 (extends 뒤에 단 하나의 부모 클래스만!)
		- 자바는 다중 상속을 허용하지 않음 
		- 그렇기 때문에 여러 개의 부모 클래스를 상속이 불가 
	2. 부모 클래스에서 private 접근 제한을 갖는 필드와 메서드는 상속 대상에서 제외 
		- 부모 클래스와 자식 클래스가 다른 패키지에 존재한다면 default 접근 제한을 갖는 필드와 메서드도 상속 대상에서 제외 

### 부모 생성자 호출 
- 자식 객체를 생성하면, 부모 객체가 먼저 생성되고 그 다음에 자식 객체가 생성 
```java
DmbCellPhone dmbCellPhone = new DmbCellPhone();
```
![[Pasted image 20240603002647.png]]
- 모든 객체는 클래스의 생성자를 호출해야만 생성 
- 자식이 부모의 생성자를 직접적으로 호출하지 않더라도 컴파일가 아래처럼 호출 
```java
public DmbCellPhone(){
	super()
}
```
- super()가 바로 부모의 기본 생성자를 호출 
- 직접 자식 생성자를 선언하고 명시적으로 부모 생성자를 호출하고 싶다면 다음과 같이 작성 
```java 
자식클래스 (매개변수선언, ...){
	super( 매개값, ....);
	....
}
```
- super()를 호출할때 부모의 생성자에 매개변수의 타입과 일치하는 생성자가 없다면 에러가 발생 

### 메서드 재정의 
- 부모 클래스의 모든 메서드를 자식 클래스가 상속 받아서 기능 그대로 사용할 수도 있지만 기능을 변경해야 할 때도 생긴다. 
- 이런 경우 상속된 일부 메서드는 자식 클래스에서 다시 수정해서 사용해야 함 
- 자바는 이런 경우는 위해 메서드 재정의(Overriding) 기능을 제공 
#### 방법 
- 메서드 재정의는 자식 클래스에서 부모 클래스의 메서드를 다시 정의하는 것을 의미 
- 메서드를 재정의할 때는 다음과 같은 규칙에 주의 
	- 부모의 메서드와 동일한 시그니처(리턴 타입, 메서드 이름, 매개 변수 목록)을 가져야 함 
	- 접근 제한을 더 강하게 재정의할 수 없음 
	- 새로운 예외를 throws할 수 없음 
![[Pasted image 20240603004008.png]]

### 부모 메서드 호출 
- 자식 클래스에서 부모 클래스의 메서드를 재정의하면 부모 클래스의 메서드는 숨겨지고 재정의된 자식 메서드만 사용됨 
- 그러나 자식 클래스 내부에서 재정의된 부모 클래스의 메서드를 호출해야 하는 상황이 발생한다면 명시적으로 super 키워드를 붙여서 부모 메서드를 호출할 수 있음 
```
super.부모메서드()
```

![[Pasted image 20240603004231.png]]

### final 클래스와 final 메서드 
- final 키워드는 클래스, 필드, 메서드를 선언할 때 사용할 수 있음 
- 해당 선언이 최종 상태이고 그 뒤에 수정될 수 없음을 뜻함 

#### 상속 불가 
- 클래스를 선언할 때 final 키워드를 class 앞에 붙이면 이 클래스는 최종적인 클래스이므로 상속할 수 없는 클래스가 됨 
- 즉 final 클래스는 부모 클래스가 될 수 없어 지식 클래스를 만들 수 없다 
```java
public final class 클래스 {....}
```
#### 재정의 불가 
- 메서드를 선언할 때 final 키워드를 붙이면 이 메서드는 최종적인 메서드이므로 재정의할 수 없음 
- 즉 부모 클래스를 상속해서 자식 클래스를 선언할 때 부모 클래스에 선언된 final 메서드는 자식 클래스에서 재정의할 수 없다는 것을 의미 

### protected 접근 제한자 
- protected는 public과 default 접근 제한의 중간쯤에 해당 
- 같은 패키지에서는 default와 같이 접근 제한이 없지만 다른 패키지에서는 자식 클래스만 접근을 허용 
![[Pasted image 20240603004835.png]]


## 타입 변환과 다형성 
- 다형성은 사용 방법은 동일하지만 다양한 객체를 이용해서 다양한 실행결과를 나오도록 하는 성질 
![[Pasted image 20240603004949.png]]
- 다형성을 구현하려면 메서드 재정의와 타입 변환이 필요 
### 자동 타입 변환 
- 타입 변환이란 타입을 다른 타입으로 변환하는 행위를 말함 
- 클래스의 변환은 상속 관계에 있는 클래스 사이에서 발생 
- 자식은 부모 타입으로 자동 타입 변환이 가능 
- 자동 타입 변환(promotion)은 프로그램 실행 도중에 자동적으로 타입 변환이 일어나는 것을 의미 
- 자동 타입 변환은 다음과 같은 조건에서 일어남 
![[Pasted image 20240603012323.png]]

- 자동 타입 변환의 개념은 자식은 부모의 특징과 기능을 상속받기 때문에 부모와 동일하게 취급될 수 있다는 것 
- 고양이가 동물의 특징과 기능을 상속받았다면 '고양이는 동물이다'가 성립 
![[Pasted image 20240603012359.png]]

![[Pasted image 20240603012623.png]]

![[Pasted image 20240603012700.png]]
- cat == animal의 결괏값을 확인해보면 true가 나오는데 이는 참조 번지가 같다는 의미 
- 곧 두 변수가 동일한 객체를 참조하고 있다는 뜻 
![[Pasted image 20240603012810.png]]
- D 객체는 B와 A 타입으로 자동 변환이 될 수 있음 
- 마찬가지로 E 객체는 C와 A 타입으로 자동 타입 변환이 될 수 있음 
- 하지만 D 객체는 C타입으로 변환될 수 없으면 E 객체 또한 B타입으로 변환될 수 없다ㅣ 
	- 상속 관계가 아니기 때문에 불가하다 

![[Pasted image 20240603013119.png]]
- 부모 타입으로 자동 타입 변환된 이후에는 부모 클래스에 선언된 필드와 메서드만 접근이 가능
- 변수는 자식 객체를 참조하지만 변수로 접근 가능한 멤버는 부모 클래스 멤버로만 한정됨 
- 예외로는 메서드가 자식 클래스에서 재정의되었다면 자식 클래스의 메서드가 대신 호출 

### 필드의 다형성 
- 자동 타입이 존재하는 이유는 다형성을 구현하기 위해서 존재함 
- 필드의 타입을 부모 타입으로 선언하면 다양한 자식 객체들이 저장될 수 있기 때문에 필드 사용 결과가 달라질 수 있음 (필드의 다형성 )

## 추상 클래스 
- 객체를 직접 생성할 수 있는 클래스를 실체 클래스라고 한다면 이 클래스들의 공통적인 특성을 추출해서 선언한 클래스를 추상 클래스라고 함 
- 추상 클래스와 실체 클래스는 상속의 관계를 가지고 있음 
- 추상 클래스가 부모, 실체 클래스가 자식으로 구현되어 실체 클래스는 추상 클래스의 모든 특성을 물려받고, 추가적인 특성을 가질 수 있음 
	- 여기서 특성은 필드와 메서드 
![[Pasted image 20240603015109.png]]
- 실체 클래스에서 공통되는 필드와 메서드를 따로 선언한 Animal.class 클래스를 만들 수 있는데 이것이 바로 추상 크래스 
### 용도 
- 공통된 필드와 메서드의 이름을 통일할 목적 
- 실체 클래스를 작성할 때 시간 절약 
![[Pasted image 20240603015806.png]]
![[Pasted image 20240603015833.png]]
### 추상 메서드와 재정의 
- 추상 클래스는 실체 클래스가 공통적으로 가져야 할 필드와 메서드들을 정의해놓은 추상적인 클래스로, 실체 클래스의 멤버(필드, 메서드)를 통일하는데 목적이 있음
- 모든 실체들이 가지고 있는 메서드의 실행 내용이 동일하다면 추상 클래스에 메서드를 작성하는 것이 좋음 
- 동물이라는 추상 크래스에 sound이라는 메서드가 있다면 해당 sound이라는 메서드의 기능을 동물마다 모두 달라야 할 것임 
- 이때 sound 메서드에 abstract를 붙인다면 해당 추상 클래스의 하위 클래스는 반드시 sound 라는 기능을 구현해야 함 
![[Pasted image 20240603020502.png]]

# 추상 클래스와 인터페이스 
## 인터페이스 
- 인터페이스(interface)는 개발 코드와 객체가 서로 통신하는 접점 역할을 함 
- 개발 코드가 인터페이스의 메소드를 호출하면 인터페이스는 객체의 메소드를 호출 
- 개발 코드는 객체의 내부 구조를 알 필요가 없고 인터페이스의 메소드만 알고 있으면 됨 
### 사용하는 이유 
- 개발 코드를 수정하지 않고 사용하는 객체를 변경할 수 있도록 하기 위해서 사용 
- 인터페이스는 하나의 객체가 아니라 여러 객체들과 사용이 가능하므로 어떤 객체를 사용하느냐에 따라서 실행 내용과 리턴값이 다름 
- 그로 인하여 개발 측면에서는 코드 변경 없이 실행 내용과 리턴값을 다양화할 수 있다는 장점을 가짐 
![[Pasted image 20240602130912.png]]
### 선언 
```
[ public ] interface 인터페이스 이름 {....}
```
- 인터페이스 이름은 클래스 이름을 작성하는 것과 동일 

```
interface 인터페이스 이름{
	// 상수 
	타입 상수이름 = 값;

	// 추상 메서드 
	타입 메소드이름(매개변수, ....);
}
```
### 상수 필드 
- 인터페이스는 객체 사용 방법을 정의한 것
- 그렇기 때문에 실행 시 **데이터를 저장할 수 있는 인스턴스 또는 정적 필드를 선언할 수 없음**
- 그러나 상수 필드(contant field)는 선언 가능 
- 단 상수는 인터페이스에 고정된 값으로 실행 시에 데이터를 바꿀 수 없음 
- **인터페이스에 선언된 필드는 모두 public static final의 특성을 가지고 있음**
- **생략하더라도 컴파일 과정에서 자동을 붙임**
```
[ public static final ] 타입 상수이름 = 값;
```
- 상수 이름은 대문자로 작성하되, 서로 다른 단어로 구성되어 있을 경우에는 언더바로 연결 
	- 필수는 아니라 관례임 
	- MODEL
	- MAX_VALUE
### 추상 메서드 선언
- 인터페이스를 통해 호출된 메서드는 최종적으로 객체에서 실행 
- 그렇기 때문에 인터페이스의 메서드는 실행 블록이 필요 없는 추상 메서드로 선언 
- 추상 메서드
	- 리턴 타입, 메서드 이름, 매개 변수만 기술하고 중괄호를 붙이지 않는 메서드를 의미 
	- public abstract의 특성을 갖고 있음 
	- 생략하더라도 컴파일 과정에서 자동으로 붙임 
![[Pasted image 20240602152607.png]]

### 인터페이스 구현 
 - 개발 코드가 인터페이스 메서드를 호출하면 인터페이스는 객체의 메서드를 호출 ㄹ
 - 객체는 인터페이스에서 정의된 추상 메서드와 동일한 메서드 이름, 매개 타입, 리턴 타입을 가진 실체 메서드를 가지고 있어야 함 
 - 이러한 객체를 인터페이스 구현(implement) 객체라고 함 
 - 구현 객체를 생성하는 클래스를 구현 클래스라고 함 
![[Pasted image 20240602154236.png]]
#### 구현 클래스 
- 구현 클래스는 보통의 클래스와 동일하지만 인터페이스 타입으로 사용할 수 있음을 알려주기 위해 클래서 선언부에 implements 키워드를 추가하고 인터페이스 이름을 명시 
- 인터페이스에 선언된 추상 메서드의 실체 메서드를 선언 
```
public class 구현클래스이름 implements 인터페이스이름{
  //인터페이스에 선언된 추상 메서드의 실체 메서드 선언 
}
```

#### 다중 인터페이스 구현 
- 객체는 다음 그림과 같이 다수의 인터페이스 타입으로 사용할 수 있음 
![[Pasted image 20240603001052.png]]
- 인터페이스 A와 인터페이스 B가 객체의 메서드를 호출할 수 있으려면 객체는 이 두 인터페이스를 모두 구현해야 함 
- 따라서 구현 클래스는 다음과 같이 작성되어야 함 
```java
public class 구현클래스이름 implements 인터페이스A, 인터페이스B{
	// 인터페이스 A에 선언된 추상 메서드의 실체 메서드 선언 
	// 인터페이스 B에 선언된 추상 메서드의 실체 메서드 선언 
}
```


